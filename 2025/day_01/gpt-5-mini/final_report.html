<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>AoC 2025, Day 1: Secret Entrance</title>
  <style>
    body { background:#0b1020; color:#d6e0ff; font-family: Inter, Roboto, Arial; max-width:1000px; margin:2rem auto; padding:2rem; }
    h1,h2 { color:#fff; }
    .meta { color:#9fb0ff; }
    pre { background:#071028; padding:1rem; border-radius:6px; overflow:auto; }
    .code { background:#071028; padding:1rem; border-radius:6px; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:1rem; }
    .darkcard { background:#071028; padding:1rem; border-radius:8px; }
    .viz { height:400px; }
    a { color:#7fd7ff }
    .small { color:#9fb0ff; font-size:0.9rem }
  </style>
</head>
<body>
<h1>AoC 2025, Day 1: Secret Entrance</h1>
<p class="meta">Author: gpt-5-mini | <a href="https://adventofcode.com/2025/day/1">Task page</a></p>

<h2>Краткое содержание задачи</h2>
<p>Есть круговой диск с числами 0..99. Он изначально указывает на 50. Во входных данных — список поворотов, например R8 или L30. Каждый поворот делает серию шагов (кликов) по одному числу за шаг. В Part 1 требуется посчитать, сколько раз диск указывает на 0 после окончания какого-либо поворота. В Part 2 — сколько раз диск указывает на 0 в любой момент (включая промежуточные клики внутри поворота).</p>

<h2>Подходы и алгоритмы</h2>
<div class="grid">
  <div class="darkcard">
    <h3>Part 1</h3>
    <p>Простая симуляция: стартовая позиция pos=50. Для каждой строки парсим направление и величину d. Обновляем позицию по модулю 100: pos = (pos ± d) % 100. Если pos == 0 — увеличиваем счётчик.</p>
    <p>Сложность: O(N) операций, где N — число строк.</p>
  </div>
  <div class="darkcard">
    <h3>Part 2</h3>
    <p>Нужно посчитать, сколько значений t в диапазоне 1..d дают (pos ± t) ≡ 0 (mod 100). Это можно посчитать математически без перебора каждого клика:</p>
    <ul>
      <li>Для хода вправо (pos + t): ищем t ≡ -pos (mod 100). Пусть target = (-pos) mod 100. Если target == 0, то целые кратные 100 внутри 1..d дают count = d // 100. Иначе, если target > d, count = 0; иначе count = 1 + (d - target) // 100.</li>
      <li>Для хода влево (pos - t): ищем t ≡ pos (mod 100). Если pos == 0, тогда target behaves like 100 for counting кратных, count = d //100. Иначе аналогично: if pos > d -> 0 else 1 + (d-pos)//100.</li>
    </ul>
    <p>Это даёт O(1) для каждой строки, итоговая сложность O(N).</p>
  </div>
</div>

<h2>Основные тонкости (gotchas)</h2>
<ul>
  <li>Важно учесть, что если target==0 (требуется попасть в 0 при шаге, t ≡0 mod100), то первые такие клики происходят при t=100,200,... — нужно использовать d//100.</li>
  <li>При подсчёте промежуточных кликов итоговое положение после поворота (t=d) уже включается в подсчёт, если оно равно 0 — дополнительного прибавления не требуется.</li>
  <li>Следует аккуратно работать с операцией взятия по модулю для отрицательных значений в языках с разной семантикой остатка; здесь использованы Python-выражения (pos - d) % 100 и (-pos) % 100 для корректности.</li>
</ul>

<h2>Инфографика и визуализация</h2>
<p>Ниже — интерактивная визуализация движений диска по кругу. Внутри HTML подключён сгенерированный файл input.js, который содержит массив строк входа (реальный ваш input). Визуализация показывает последовательность поворотов, подсчитывает и отображает события достижения 0 как промежуточные и итоговые.</p>
<div id="viz" class="darkcard">
  <canvas id="canvas" class="viz"></canvas>
  <div class="small">Используйте ползунок чтобы просмотреть первые K поворотов и кнопку «Play» для анимации.</div>
  <div style="margin-top:8px">
    <input id="range" type="range" min="1" max="1" value="1" style="width:70%">
    <button id="play">Play</button>
    <span id="info"></span>
  </div>
</div>

<script src="input.js"></script>
<script>
// input.js defines const INPUT = [...];
(function(){
  const rotations = INPUT; // array of strings
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = Math.min(900, window.innerWidth-100);
  canvas.height = 400;

  const N = rotations.length;
  const range = document.getElementById('range');
  const playBtn = document.getElementById('play');
  const info = document.getElementById('info');
  range.max = N; range.value = Math.min(200, N);

  // precompute movements and counts (same logic as solution)
  function analyze(rotations){
    let pos = 50;
    const steps = [];
    let endCount = 0, duringCount = 0;
    for(let i=0;i<rotations.length;i++){
      const s = rotations[i].trim();
      if(!s) continue;
      const dir = s[0];
      const d = parseInt(s.slice(1),10);
      let occ = 0;
      if(dir==='R'){
        const target = ((-pos)%100 + 100)%100;
        if(target===0) occ = Math.floor(d/100);
        else if(target> d) occ = 0;
        else occ = 1 + Math.floor((d - target)/100);
        pos = (pos + d) % 100;
      } else {
        const target = pos % 100;
        if(target===0) occ = Math.floor(d/100);
        else if(target > d) occ = 0;
        else occ = 1 + Math.floor((d - target)/100);
        pos = ((pos - d) % 100 + 100) % 100;
      }
      duringCount += occ;
      if(pos===0) endCount++;
      steps.push({dir,d,occ,after:pos});
    }
    return {steps,endCount,duringCount};
  }

  const result = analyze(rotations);

  function draw(k){
    // draw circle with numbers, highlight positions visited up to k
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cx = canvas.width/2;
    const cy = canvas.height/2;
    const R = Math.min(cx,cy)-60;

    // draw circle
    ctx.strokeStyle='#2a3a66'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();

    // draw ticks and numbers every 5
    for(let i=0;i<100;i++){
      const a = (i/100)*Math.PI*2 - Math.PI/2;
      const x = cx + Math.cos(a)*R;
      const y = cy + Math.sin(a)*R;
      if(i%10===0){
        ctx.fillStyle='#9fb0ff'; ctx.font='12px monospace'; ctx.fillText(String(i), x-6, y+4);
      } else if(i%5===0){
        ctx.fillStyle='#607ea8'; ctx.fillRect(x-1,y-1,2,2);
      }
    }

    // simulate each rotation up to k and mark zeros
    let pos = 50;
    let x0 = cx + Math.cos(-Math.PI/2)*R;
    let y0 = cy + Math.sin(-Math.PI/2)*R;

    // draw path as arcs per rotation
    let angle0 = -Math.PI/2 + (50/100)*Math.PI*2;
    const arcAlpha = 0.12;
    for(let i=0;i<k;i++){
      const step = result.steps[i];
      if(!step) break;
      const dir = step.dir; const d = step.d;
      const oldPos = pos;
      let newPos = pos;
      if(dir==='R') newPos = (pos + d)%100; else newPos = ((pos - d)%100+100)%100;
      const a1 = -Math.PI/2 + (oldPos/100)*Math.PI*2;
      const a2 = -Math.PI/2 + (newPos/100)*Math.PI*2;

      // draw small arc showing movement
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(125,200,255,'+arcAlpha+')'; ctx.lineWidth=8;
      // draw arc in direction
      const anticlockwise = (dir==='L');
      // normalize angles for canvas arc drawing
      let sa = a1, ea = a2;
      // ensure we draw the shortest direction corresponding to movement length
      // because movement may go multiple full turns, approximate by drawing direct arc
      ctx.arc(cx,cy,R,sa,ea,anticlockwise);
      ctx.stroke();

      // mark zeros encountered during this rotation
      // we will mark the zero point and label occ
      if(step.occ>0){
        const az = -Math.PI/2 + (0/100)*Math.PI*2;
        const zx = cx + Math.cos(az)*R;
        const zy = cy + Math.sin(az)*R;
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath(); ctx.arc(zx,zy,10,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#071028'; ctx.font='bold 12px monospace'; ctx.fillText(String(step.occ), zx+12, zy+4);
      }
      pos = newPos;
    }

    // draw current pointer
    const pointerAngle = -Math.PI/2 + (pos/100)*Math.PI*2;
    const px = cx + Math.cos(pointerAngle)*R;
    const py = cy + Math.sin(pointerAngle)*R;
    ctx.fillStyle='#7fffd4'; ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();

    info.textContent = `Steps shown: ${k} / ${rotations.length} — end zeros: ${result.endCount}, during zeros (total): ${result.duringCount}`;
  }

  range.addEventListener('input',()=> draw(parseInt(range.value,10)));
  let playing = false; let tId = null;
  playBtn.addEventListener('click',()=>{
    if(!playing){ playing=true; playBtn.textContent='Pause'; tId = setInterval(()=>{ let v=parseInt(range.value,10); if(v<rotations.length) range.value = v+1; else { clearInterval(tId); playing=false; playBtn.textContent='Play'; } range.dispatchEvent(new Event('input')); }, 150);} else { clearInterval(tId); playing=false; playBtn.textContent='Play'; }
  });

  // initial draw
  draw(parseInt(range.value,10));
})();
</script>

<h2>Анализ входных данных</h2>
<div class="grid">
  <div class="darkcard">
    <h3>Статистика</h3>
    <pre id="stats">Вычислено автоматически при генерации отчёта.</pre>
  </div>
  <div class="darkcard">
    <h3>Немного юмора</h3>
    <p>Если диск показывает ноль так часто, может, он просто обиделся на свои обязанности и решил маркировать отпуск: "Я на нуле!"</p>
  </div>
</div>

<h2>Код решения</h2>
<p>Файлы, использованные при решении (Python):</p>

<h3>solve_day1_part1.py</h3>
<pre class="code"><code># solve_day1_part1.py
# Решение Part 1: симуляция поворотов и подсчёт конечных положений, равных 0.
from pathlib import Path

def solve_part1(input_path: Path) -> int:
    pos = 50
    count_zero = 0
    for line in input_path.read_text().strip().splitlines():
        line = line.strip()
        if not line:
            continue
        dir_char = line[0]
        val = int(line[1:])
        if dir_char == 'L':
            pos = (pos - val) % 100
        else:
            pos = (pos + val) % 100
        if pos == 0:
            count_zero += 1
    return count_zero

if __name__ == '__main__':
    from pathlib import Path
    inp = Path('input.txt')
    ans1 = solve_part1(inp)
    print(f"Part 1: {ans1}")
</code></pre>

<h3>solve_day1_part2.py</h3>
<pre class="code"><code># solve_day1_part2.py
# Решение Part 2: подсчёт кликов, приводящих диск к 0 внутри поворота, без поэтапного перебора.
from pathlib import Path
from typing import Tuple

def count_visits_and_final_pos(lines) -> Tuple[int,int,int]:
    pos = 50
    end_zero_count = 0
    during_zero_count = 0
    for line in lines:
        line = line.strip()
        if not line:
            continue
        dir_char = line[0]
        d = int(line[1:])
        if dir_char == 'R':
            target = (-pos) % 100
            if target == 0:
                occ = d // 100
            else:
                if target > d:
                    occ = 0
                else:
                    occ = 1 + (d - target) // 100
            pos = (pos + d) % 100
        else:
            target = pos % 100
            if target == 0:
                occ = d // 100
            else:
                if target > d:
                    occ = 0
                else:
                    occ = 1 + (d - target) // 100
            pos = (pos - d) % 100
        during_zero_count += occ
        if pos == 0:
            end_zero_count += 1
    return end_zero_count, during_zero_count, pos

if __name__ == '__main__':
    p = Path('input.txt')
    lines = p.read_text().strip().splitlines()
    end_zero, during_zero, final_pos = count_visits_and_final_pos(lines)
    print(f"Part 1: {end_zero}")
    print(f"Part 2: {during_zero}")
</code></pre>

<p>Файл input.js (сгенерирован автоматом) подключён в отчёте и содержит ваш реальный вход.</p>

<h2>Проблемы и отладка</h2>
<p>Проблем не возникло. Основная потенциальная ошибка — неправильное учёт кратных 100 или двойной учёт конечного положения; это было проверено на примерах.</p>

</body>
</html>